use std::path::Path;

use crate::KllGroups;

#[cfg(test)]
mod test {
    use crate::types::KllFile;
    use std::collections::HashMap;
    use std::fs;

    #[test]
    fn trigger() {
        let test = fs::read_to_string("examples/kllcoretest.kll").unwrap();
        let result = KllFile::from_str(&test);
        let state = result.unwrap().into_struct();

        // Generate trigger guides
        let mut trigger_guides = Vec::new();
        for trigger_list in state.trigger_lists() {
            let mut guide = trigger_list.kll_core_guide();
            trigger_guides.append(&mut guide);
        }
    }

    #[test]
    fn result() {
        let test = fs::read_to_string("examples/kllcoretest.kll").unwrap();
        let result = KllFile::from_str(&test);
        let state = result.unwrap().into_struct();

        // Generate result guides
        let mut result_guides = Vec::new();
        for result_list in state.result_lists() {
            let mut guide = result_list.kll_core_guide();
            result_guides.append(&mut guide);
        }
    }

    #[test]
    fn trigger_result() {
        let test = fs::read_to_string("examples/kllcoretest.kll").unwrap();
        let result = KllFile::from_str(&test);
        let state = result.unwrap().into_struct();

        // Trigger and Result deduplication hashmaps
        let mut trigger_hash = HashMap::new();
        let mut result_hash = HashMap::new();

        // Trigger:Result mapping hashmap
        let mut trigger_result_hash = HashMap::new();

        // Generate trigger and result guides as well as the trigger result mapping
        let mut trigger_guides = Vec::new();
        let mut result_guides = Vec::new();
        let mut trigger_result_map: Vec<u16> = Vec::new();
        for (trigger_list, result_list) in state.trigger_result_lists() {
            let mut trigger_guide = trigger_list.kll_core_guide();
            // Determine if trigger guide has already been added
            let trigger_pos =
                match trigger_hash.try_insert(trigger_guide.clone(), trigger_guide.len()) {
                    Ok(pos) => {
                        trigger_guides.append(&mut trigger_guide);
                        *pos
                    }
                    Err(err) => err.entry.get().clone(),
                };

            let mut result_guide = result_list.kll_core_guide();
            // Determine if result guide has already been added
            let result_pos = match result_hash.try_insert(result_guide.clone(), result_guide.len())
            {
                Ok(pos) => {
                    result_guides.append(&mut result_guide);
                    *pos
                }
                Err(err) => err.entry.get().clone(),
            };

            // Add trigger:result mapping
            if trigger_result_hash
                .insert((trigger_guide, result_guide), (trigger_pos, result_pos))
                .is_none()
            {
                trigger_result_map.push(trigger_pos as u16);
                trigger_result_map.push(result_pos as u16);
            }
        }
    }

    #[test]
    fn layer_lookup_simple() {
        // TODO

        // Generate layer lookup
        // TODO - Needs double hash-table
        //        1. guide to trigger index
        //        2. guide element to trigger index
    }

    #[test]
    fn generate_binary() {
        // TODO Needs an offset table for the firmware to know where the pointers
        // are
    }

    #[test]
    fn generate_rust() {
        // TODO
    }
}

#[derive(Copy, Clone, Debug, PartialEq)]
pub enum Error {
    ParsingError,
    UnknownError,
}

pub fn verify(_groups: &KllGroups) -> Result<(), Error> {
    Ok(())
}

pub fn write(_file: &Path, _groups: &KllGroups) {
    /*
    let config = groups.config();
    let mut capabilities = config
        .capabilities
        .values()
        .map(|cap| Capability(cap.function, cap.args.len()))
        .collect::<Vec<_>>();
    capabilities.sort_by_key(|cap| cap.0);

    let data = KIIBOHD_DATA;
    let content = format!(
        include_str!("kiibohd_keymap_template.h"),
        information = "// This file was generated by the kll compiler, DO NOT EDIT",
        capabilities_func_decl = capabilities
            .iter()
            .map(|cap| cap.func_decl_str())
            .collect::<Vec<_>>()
            .join("\n"),
        capabilities_list = capabilities
            .iter()
            .enumerate()
            .map(|(i, cap)| cap.cap_str(i))
            .collect::<Vec<_>>()
            .join("\n"),
        result_macros = data
            .results
            .iter()
            .enumerate()
            .map(|(i, result)| result.guide_str(i))
            .collect::<Vec<_>>()
            .join("\n"),
        result_macro_list = data
            .results
            .iter()
            .enumerate()
            .map(|(i, result)| result.define_str(i))
            .collect::<Vec<_>>()
            .join("\n"),
        trigger_macros = data
            .triggers
            .iter()
            .enumerate()
            .map(|(i, result)| result.guide_str(i))
            .collect::<Vec<_>>()
            .join("\n"),
        trigger_macro_list = data
            .triggers
            .iter()
            .enumerate()
            .map(|(i, result)| result.define_str(i))
            .collect::<Vec<_>>()
            .join("\n"),
        max_scan_code = data.max_scan_code,
        default_layer_trigger_list = data
            .default_layer
            .iter()
            .enumerate()
            .map(|(i, result)| result.define_str(i))
            .collect::<Vec<_>>()
            .join("\n"),
        partial_layer_trigger_lists = data
            .partial_layers
            .iter()
            .enumerate()
            .map(|(i, result)| result.define_str(i))
            .collect::<Vec<_>>()
            .join("\n"),
        scancode_interconnect_offset_list = data
            .scancode_offsets
            .iter()
            .map(|x| format!("\t{:#04X},", x))
            .collect::<Vec<_>>()
            .join("\n"),
        default_layer_scanmap = (0..data.default_layer.len())
            .map(|x| format!("default_tl_{:#04X}", x))
            .collect::<Vec<_>>()
            .join(", "),
        partial_layer_scanmaps = (0..data.partial_layers.len())
            .map(|x| format!("default_tl_{:#04X}", x))
            .collect::<Vec<_>>()
            .join(", "),
        layer_index_list = data
            .layer_indices
            .iter()
            .map(|layer| layer.define_str())
            .collect::<Vec<_>>()
            .join("\n"),
        rotation_parameters = "",
        key_positions = data
            .positions
            .iter()
            .map(|pos| pos.define_str())
            .collect::<Vec<_>>()
            .join("\n"),
        utf8_data = "",
    );
    fs::write(file, content).unwrap();
    */
}
